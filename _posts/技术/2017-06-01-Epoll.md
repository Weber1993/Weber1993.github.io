---
layout: post
title: select、poll、epoll的归纳总结区分
category: 技术
tags: 网络
keywords: 
select、poll、epoll的归纳总结区分: 
---


简介
---

**1. select**

　　select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样的缺点如下：

　　1). 单个进程可见是的fd数量被限制；

　　2). 需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大；

　　3). 对socket进行扫描时是线性扫描；

**2. poll**

　　poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待列表中加入一项并继续遍历，如果遍历完所有的fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后他又要再次遍历fd。这个过程经历了多次不必要的遍历；
　　它没有最大连接数的限制，原因是由于他是基于链表来存储的，但是这样会有一个缺点：大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义的；
　　poll还有一个特点是：水平触发，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。

**3. epoll**

　　epoll支持水平出发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。

　　在前边说到的复制问题上，epoll使用mmap减少复制开销；

　　epoll使用“事件”的就绪方式通知，通过epoll_ctl注册fd,一旦该fd就绪，内核就回采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知；

**注：**


**水平触发**（level-triggered）——只要满足条件，就触发一个事件（只要有数据没有被获取，内核就不断的进行通知）；


**边缘触发**（edge-triggered）——每当状态变化时，就触发一个事件；

区别
---

**1. select** 

　　支持最大连接数：1024（x86）、2048（x64）； IO效率：每次调用进行线性遍历，时间复杂度为O(n)； fd拷贝：每次select都拷贝；

**2. poll** 

　　支持最大连接数：无上限； IO效率：每次调用进行线性遍历，时间复杂度为O(n)； fd拷贝：每次poll都拷贝；

**3. epoll** 

　　支持最大连接数：无上限； IO效率：使用“事件”通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到rdllist里面，这样epoll_wait返回的时候我们就拿到了就绪的fd，时间复杂度为O(1)； fd拷贝：调用epoll_ctl时拷贝进内核并由内核保存，之后每次epoll_wait不拷贝；

性能比较
---

当fd数量较少的时候，poll略优于epoll，但是当fd增大到某个阈值时，poll性能急剧下降，而epoll始终保持稳定的性能；

使用
---

同事需要保持很多的长连接，而且链接的开关很频繁，最高效的模型就是非阻塞、异步IO模型。而且不要使用select/poll，这两个API都有着O(n)的时间复杂度。在Linux下使用epoll,或者用libevent封装的统一接口（对于不同平台的libevent实现时采用各个特有的API），这些平台特有的API时间复杂度为O（1）。然而在非阻塞，异步I/O模型下的编程是非常痛苦的。由于I/O操作不再阻塞，报文的解析需要小心翼翼，并且需要亲自管理维护每个连接的状态。并且为了充分利用CPU，还应结合线程池，避免在轮询线程中处理业务逻辑。

**注：**
**长连接**——连接后始终不断开，然后进行报文发送和接受；
**短链接**——每一次通讯都建立连接，通讯完成即断开连接，下次通讯再建立连接；
